if [[ "$string" == *"$substring"* ]]; then
    echo "'$string' contains '$substring'";
else
    echo "'$string' does not contain '$substring'";
fi
o bien
Regular Expressions

More advanced pattern matching can be done using regular expressions. In it’s most basic form, we can do simple substring matching like so:

if [[ "$string" =~ $substring ]]; then
    echo "'$string' contains '$substring'";
else
    echo "'$string' does not contain '$substring'";
fi

kill -l
sin embargo los más utilizados son precisamente

INT, TERM, EXIT

Si el script consiste, por ejemplo, en la sincronización de archivos con

rsync

lo más sensato es apoyarse en un archivo lock que no permita que el script se ejecute simultáneamente:

LOCK="/var/run/rsync.lock"

if [ ! -e $LOCK ]; then
    touch $LOCK
    rsync -avz foo bar
    rm $LOCK
else
   echo "rsync ya se está ejecutando"
fi

En español plano, el script anterior comprueba si existe el archivo lock y si este no existe lo crea y posteriormente ejecuta el comando correspondiente, por último elimina el archivo lock. Si existe el archivo el script simplemente envía un mensaje al usuario indicándole que ya el comando se está ejecutando.

Sin embargo cuando una hay una situación problemática pudiera pasar que el archivo lock no se elimine dando al traste con efectos indeseados. La solución es bien sencilla:

LOCK="/var/run/rsync.lock"

if [ ! -e $LOCK ]; then
   trap "rm -f $LOCK; exit" INT TERM EXIT
   touch $LOCK
   rsync -avz foo bar
   rm $LOCK
   trap - INT TERM EXIT
else
   echo "rsync ya se está ejecutando"
fi

La particularidad de esta solución es que el comando está encerrado en un trap, de modo que cuando se recibe una señal

INT, TERM, EXIT

el script se detiene y borra el archivo lock.

Vale la pena decir que pudiera darse una situación de competencia en el script anterior entre el tiempo en que se verifica el archivo lock y el tiempo en que este se crea. Una posible solución sería usar una redirección y el modo noclobber de bash que no redirige a un archivo existente:

LOCK="/var/run/rsync.lock"

if (set -o noclobber; echo $$ > "$LOCK") 2> /dev/null;
then
    trap 'rm -f "$LOCK"; exit $?' INT TERM EXIT
    rsync -avz foo bar
    rm -f $LOCK
    trap - INT TERM EXIT
    else
        echo "rsync ya se está ejecutando: $(cat $LCK)"
fi

La particularidad de este último es que se usa como ya había dicho, el modo noclobber y que el archivo lock contiene el PID del proceso que se ejecuta.

También vale la pena mencionar que existen otras soluciones como

flock

o

solo

sin embargo en esta entrada quise compartir las soluciones con recursos propios de bash. Pueden aprender un poco más sobre Traps con esta excelente guía.
http://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html

